---
title: "Cargo, or How I Learned to Stop Worrying and Love Rust"
date: 2023-04-03
draft: false

showReadingTime: true
---


## I come from a land of Python, where tooling blows and `pip3` blunders.
Okay, okay, yeah this isn't exactly true, but I wanted to make the rhyme work, so sue me. And, while Python isn't my favourite language, it certainly is my most used, being what I code in at work. This has put me in a nice position where I have seen a lot of the tooling that Python uses, experienced a lot of its alternatives, and suffered from some of its quirks. This gave me an interesting reference point from which to come into Rust, and feel the difference a tightly-integrated and planned-from-the-beginning approach made to building such tooling.

> **Author's Note:** I like to exaggerate sometimes when describing how I feel about certain things. Just because I'm bashing on it doesn't mean I don't think it's powerful or even good, it just means I had to use it once at 3am for a project due that morning at 9am.

## Tooling Is a Spectrum

That is, a spectrum from, "if I have to `man` this one more time, I am actually going to give up coding and live on a farm," to the coding equivalent of "eh, whatever, I'll just fix it in post."

At the more suicidal end of this spectrum, I would like to place `C`. Do you remember using `Valgrind`? Yeah, I try not to either. Now, don't get me wrong - in terms of raw functionality, the tools that exist for C are pretty incredible. And they should be - they've had decades to be developed, refined and improved through sheer experience. Tools like `valgrind` are the results of many, many talented developers suffering through similar problems over thousands of projects. **However**, none of these systems are integrated into the language at all. Anyone who's spent time with `C` has experienced the air-strangling, hair-pulling, exhaling-loudly-through-the-nose experience that is compiling a program with `gcc` and receiving a sweet, blunt `SegmentationFault`. It's the programming language equivalent of someone flipping you off and then bailing out of the car as it hurtles towards the chasm. Consequently, I would argue that the tools that exist for `C`, such as `valgrind`, exist out of **necessity**. Without them, programming would be nightmarishly harder. On top of that, they are developed for power users - they are rarely very intuitive, because the concepts they are dealing with are often not intuitive either, and they have been developed relatively far into the language's life.

I would argue that Python sits somewhere in the middle of this spectrum. Python actually does have some quite nice tools. However, in Python's case, this tooling is fragmented. Python made the design decision to provide stack traces on a program crash, which is already substantially more intuitive than C's not-my-problem approach. A new user picking up Python can look at this and, with a little bit of understanding, get a decent idea of where to start looking with their error very easily. For tools that do more than this, however, you need to look beyond the interpreter itself. Many linters exist, for example. You can also find type-checkers that enforce static types (like `my-py`). These tools are also really quite good. Additionally, the modularity means that it is easy for developers to take existing solutions and build something new, if they feel the existing solutions are lacking in some way. This gives the end-user developers a lot of choice and power over how they want to use the language. People writing short scripts might choose to just have a very loose linting system (or maybe even no linter at all), while groups collaborating on larger projects might want a strict linter like `pylint`, or one with static-type checking, like `my-py`.

However, this approach has disadvantages too. You might not realise that you can be using these tools, or might need to rely on word-of-mouth to hear about a certain solution. You are also left not sure which solution to choose, and occassionally with solutions that break when used together. I know personally, I have had linters break on me and my solution is to simply try another one. While this could be good, I think it is arguable that from a user-friendly point-of-view, the best solution is one that just works.

## Rust Goes Big

This brings us to Rust, which is at the complete opposite end of the spectrum to C. Rust is a language that, from the outset, has sought to tightly integrate the tools that developers will find useful. Not only should these tools work right out of the box, but they should be easily accessible to users through either the cargo commands or IDE plugins. This is only possible because Rust itself, as a langauge, is very strict, and so the developers do not have to worry about different use cases like you might see in Python. Rust's tooling is excellent because:
- **It was considered from the outset**. This means it is easier for developers to evolve it with the language, rather than the tools being less mature than the langauge itself. Conseuently, the error messages are robust and carefully considered, as are the suggested actions.
- **The tools have the full focus of the langauge's developers itself**. This meant that it was able to tightly couple with the langauge, making it far more intuitive to react to error messages than in other langauges, as you can easily see in the output of `cargo run`. It was not an afterthought, nor a response from the community. It was a first-class citizen of the development environment. The tools are so good that often you can just quick-fix an error, and `rust-analyzer` will be right. It just worksâ„¢.
- **You don't rely on the community**. As someone who daily drives Linux and uses a window manager, I know first-hand how powerful environments can be where the elements are all modular and developed by separate people or communities. However, relying on this (such as with tools like `nvm` and `rbenv`) in actual development environments can be less intuitive, as you are more expected to find out these things on your own (or through guides, etc). The information isn't always there in the language itself, adding one more step you need to do to become proficient in that language. Tools like `cargo`, `rust-analyzer` and `rustup` are so fantastic because such care and time has been put in to them that a community alternative isn't even really necessary. This avoids the feeling that community solutions exist as a bandaid to something the language creators neglected to do themselves, and equally avoids the sense of being fractured between alternative solutions where pros and cons aren't always clear.

So, yeah. Using `cargo` after `npm` is like taking a hot bath in the middle of winter.
